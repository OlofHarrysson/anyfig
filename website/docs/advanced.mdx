---
id: advanced
title: Advanced Features
sidebar_label: Advanced
---

## Command Line Input

Anyfig offers the functionality to override config values through command line arguments and will throw an error if the user inputs a key that doesn't exist. It's thus only possible to **override argument**, not to define new ones.

```python
import anyfig

@anyfig.config_class
class MyConfig():
  def __init__(self):
    self.experiment_note = 'Changed stuff'

config = anyfig.setup_config(default_config=MyConfig)

# ~~~ â¬‡ Command line â¬‡ ~~~  
# config.experiment_note will contain: A new note
python path/to/file.py --experiment_note="A new note"
```

### Argument Types
Google's [Fire project](https://github.com/google/python-fire) is used to parse command line arguments' types and validity. It support any Python literals (numbers, strings, tuples, lists, dictionaries, sets). Read more about how Fire [handles parsing](https://github.com/google/python-fire/blob/master/docs/guide.md#argument-parsing). 

 A problem arises when one wants to override a non-literal, like a Pathlib Path from the command line. Anyfig solves this by parsing the input to a Python literal and use that to create a new object from the class definition of the old value.


```python
import anyfig
from pathlib import Path

@anyfig.config_class
class MyConfig():
  def __init__(self):
    self.save_directory = Path('output')

config = anyfig.setup_config(default_config=MyConfig)

# ~~~ â¬‡ Command line â¬‡ ~~~  
# config.save_directory will be a Path object with value: other_output
# It's created by wrapping the input string in a Path object: Path("other_output")
python path/to/file.py --save_directory="other_output"
```

## Multiple Config Classes

Sometimes it's useful to have multiple config-classes. Perhaps one config for every main script or one config for normal use and one for debugging. The ability to create multiple config-classes is very powerful and essential to Anyfig.

One can choose which config-class to use via the command line. If a config-class is not supplied, it will default to the config-class given in the anyfig.setup_config function. 


```python
import anyfig

@anyfig.config_class
class MyConfig():
  def __init__(self):
    self.experiment_note = 'Changed stuff'

@anyfig.config_class
class SecondConfig():
  def __init__(self):
    self.experiment_note = 'Number 2'
    self.anyfig_tip = 'Configs can contain different values from each other'

# The "default_config" argument decides which class is used to create the config
config = anyfig.setup_config(default_config=MyConfig)

# ~~~ â¬‡ Command line â¬‡ ~~~
# config.experiment_note will contain: Changed stuff
python path/to/file.py

# config.experiment_note will contain: Number 2
python path/to/file.py --config=SecondConfig

# It's possible to override config-classes and values at the same time
# config.experiment_note will contain: A new note
python path/to/file.py --config=SecondConfig --experiment_note="A new note"
```

### Inheritance
<details><summary>What's the object oriented way to become wealthy?</summary>
ðŸ’° Inheritance
</details>

For situations where multiple config-classes are quite similar it often makes sense to take advantage of class inheritance to avoid code duplication.  

```python
import anyfig
import logging

@anyfig.config_class
class NormalConfig():
  def __init__(self):
    self.logger = logging.getLogger('my-app')
    # ... More config values

@anyfig.config_class
class DebugConfig(NormalConfig):
  def __init__(self):
    super().__init___()  # Gets all attributes from NormalConfig
    self.logger.setLevel(logging.DEBUG)

config = anyfig.setup_config(default_config=NormalConfig)
```

### Modular Configs
For bigger configs/projects it can help to separate them


## Modular Configs
### Inheritance
### Nested

### Multiple configs & class inheritence

It's possible to have multiple config classes defined and select one at runtime. This could be useful if you e.g. have one default config and one for debugging.

To select a config class, specify the config class in the input arguments with the '--config' flag

```bash
python path/to/file.py --config=MainConfig
python path/to/file.py --config=DebugConfig
```

```python
import anyfig
import random

@anyfig.config_class
class MainConfig():
  def __init__(self):
    self.experiment_note = 'Changed some stuff'
    self.seed = random.randint(0, 80085)

@anyfig.config_class
class DebugConfig(FooConfig):
  def __init__(self):
    super().__init__() # Inherit all parameters from MainConfig
    self.seed = -1 # Overwrite
    self.new = 'Parameter not found in MainConfig'

config = anyfig.setup_config(default_config=MainConfig)
print(config) # Different output depending on which config class that was selected via the command line
```

## Multiple Configs
placeholder

## Inheritance
placeholder


## Nested Configs
placeholder
