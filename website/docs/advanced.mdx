---
id: advanced
title: Advanced Features
sidebar_label: Advanced
---

## Command Line Input

Anyfig offers the functionality to override config values through command line arguments. Anyfig will throw an error if the user inputs a key that doesn't exist making it possible to **override argument**, not to define new ones. By not allowing new keys, Anyfig protects against misspellings that can result in silent errors.

```python
import anyfig

@anyfig.config_class
class MyConfig():
  def __init__(self):
    self.experiment_note = 'Changed stuff'

config = anyfig.init_config(default_config=MyConfig)

# ~~~ â¬‡ Command line â¬‡ ~~~
# config.experiment_note will contain: A new note
python path/to/file.py --experiment_note='A new note'

# Throws an error due to missing key
python path/to/file.py --xperiment_note='A new note'
```

### Argument Types
Google's [Fire project](https://github.com/google/python-fire) is used to parse command line arguments' types and validity. It support any Python literals (numbers, strings, tuples, lists, dictionaries, sets). Read more about how Fire [handles parsing](https://github.com/google/python-fire/blob/master/docs/guide.md#argument-parsing). 

 A problem arises when one wants to override a non-literal, like a Pathlib Path, from the command line. Anyfig solves this by parsing the input to a Python literal and use that to create a new object from the class definition of the old value.

```python
import anyfig
from pathlib import Path

@anyfig.config_class
class MyConfig():
  def __init__(self):
    self.save_directory = Path('output')

config = anyfig.init_config(default_config=MyConfig)

# ~~~ â¬‡ Command line â¬‡ ~~~
# config.save_directory will be a Path object with value: other_output
# It's created by wrapping the input string in a Path object: Path('other_output')
python path/to/file.py --save_directory='other_output'
```

### Command Line Help
Help for the config-options are exposed to the command line when the user inputs the --help flag.


```python
import anyfig
from pathlib import Path

@anyfig.config_class
class MyConfig():
  def __init__(self):

    # Describes the thought behind the experiment
    self.experiment_note = 'Changed stuff'

    ''' Supports
    multiline
    comments '''
    self.save_directory = Path('output')

    self.some_values_need_no_comment = 1

# ~~~ â¬‡ Command line â¬‡ ~~~
python path/to/file.py --help

# ~~~ â¬‡ Output â¬‡ ~~~
Available config classes ['MyConfig']
Current config is 'MyConfig'. Set config with --config=OtherConfigClass

--experiment_note (str):                Describes the thought behind the experiment
--save_directory (PosixPath):           Supports
                                        multiline
                                        comments
--some_values_need_no_comment (int):
```

## Multiple Config Classes

Sometimes it's useful to have multiple config-classes. Perhaps one config for every main script or one config for normal use and one for debugging. The ability to create multiple config-classes is very powerful and essential to Anyfig.

One can choose which config-class to use via the command line. If a config-class is not supplied, it will default to the config-class given in the anyfig.init_config function. 


```python
import anyfig

@anyfig.config_class
class MyConfig():
  def __init__(self):
    self.experiment_note = 'Changed stuff'

@anyfig.config_class
class SecondConfig():
  def __init__(self):
    self.experiment_note = 'Number 2'
    self.anyfig_tip = 'Configs can contain different values from each other'

# The "default_config" argument decides which class is used to create the config
config = anyfig.init_config(default_config=MyConfig)

# ~~~ â¬‡ Command line â¬‡ ~~~
# config.experiment_note will contain: Changed stuff
python path/to/file.py

# config.experiment_note will contain: Number 2
python path/to/file.py --config=SecondConfig

# It's possible to override config-classes and values at the same time
# config.experiment_note will contain: A new note
python path/to/file.py --config=SecondConfig --experiment_note="A new note"
```

### Inheritance
<details><summary>What's the object oriented way to become wealthy?</summary>
ðŸ’° Inheritance
</details>

For situations where multiple config-classes are similar to one another it often makes sense to use inheritance to avoid code duplication.

```python
import anyfig
import logging

@anyfig.config_class
class NormalConfig():
  def __init__(self):
    self.logger = logging.getLogger('my-app')
    # ... More config values

@anyfig.config_class
class DebugConfig(NormalConfig):
  def __init__(self):
    super().__init___()  # Gets all attributes from NormalConfig
    self.logger.setLevel(logging.DEBUG)

config = anyfig.init_config(default_config=NormalConfig)
```

### Modular Configs
For projects where the configuration grows large it helps to modularize the config values. Anyfig allows for nested config-classes to both reduce code duplication and increase code readability. 

```python
import anyfig

@anyfig.config_class
class MainConfig():
  def __init__(self):
    self.experiment_note = 'Changed stuff'
    self.module = ModuleConfig()  # Yo dawg!

@anyfig.config_class
class ModuleConfig():
  def __init__(self):
    self.anyfig_tip = 'Config-classes can be used as parts or wholes'

config = anyfig.init_config(default_config=MainConfig)

# ~~~ â¬‡ Command line â¬‡ ~~~
# It's possible to override nested values
python path/to/file.py --module.anyfig_tip="A new note"
```
